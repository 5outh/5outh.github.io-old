<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Abstract Nonsense</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../js/lightbox2/dist/css/lightbox.min.css" />
    <script type="text/javascript" src="../js/lightbox2/dist/js/lightbox-plus-jquery.js"></script>
  </head>
  <body>
    <div id="left"></div>
    <div class="wrapper">
      <header>
        <ul id="nav">
    <li><a href="../">Home</a></li>
    <li><a href="../contact.html">About</a></li>
</ul>


        <h1 id="blog_title">Abstract Nonsense</h1>
      </header>
      <section>
        
          <h3 class="post-title">Symbolic Calculus in Haskell</h3>
        
        <p>
<div class="post_body">
	<h4 id="motivation">Motivation</h4>
<p>It’s relatively simple to write a program to approximate derivatives. We simply look at the limit definition of a derivative: <br /><span class="math display">$$ \frac{d}{dx}
f(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h} $$</span><br /> and choose some small decimal number to use for <span class="math inline"><em>h</em></span> instead of calculating the limit of the function as it goes to <span class="math inline">0</span>. Generally, this works pretty well. We get good approximations as long as <span class="math inline"><em>h</em></span> is small enough. However, these approximations are not quite exact, and they can only be evaluated at specific points (for example, we can find <span class="math inline">$\frac{d}{dx}f(5)$</span>, but not the actual symbolic function). So, what if we want to know what <span class="math inline">$\frac{d}{dx}f(x)$</span> is <em>for all x</em>? Calculating derivatives with this approximation method won’t do the trick for us – we’ll need something a little more powerful, which is what we will build in this post. Admittedly, this idea didn’t come to me through necessity of such a system; I was just curious. It ended up being pretty enlightening, and it’s amazing how simple Haskell makes this type of thing. Most of the code in this post didn’t take too long to write, it’s relatively short (only 108 lines total, including whitespace) and has a lot of capability. With that, let’s get started!</p>
<h4 id="the-data-type">The Data Type</h4>
<p>I don’t want to over-complicate the process of taking derivatives, so my data type for algebraic expressions is kept minimal. We support six different types of expressions:</p>
<ul>
<li>Variables (denoted by a single character)</li>
<li>Constant values</li>
<li>Addition</li>
<li>Multiplication</li>
<li>Exponentiation</li>
<li>Division</li>
</ul>
<p>This can be expanded upon, but this is adequate for the purpose of demonstration.</p>
<p>Here is our <code>Expr a</code> type, with a sample expression representing <span class="math inline">3<em>x</em><sup>2</sup></span>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">:+:</span>
<span class="kw">infixl</span> <span class="dv">5</span> <span class="fu">:*:</span>, <span class="fu">:/:</span>
<span class="kw">infixr</span> <span class="dv">6</span> <span class="fu">:^:</span>

<span class="kw">data</span> <span class="dt">Expr</span> a <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Char</span>
             <span class="fu">|</span> <span class="dt">Const</span> a 
             <span class="fu">|</span> (<span class="dt">Expr</span> a) <span class="fu">:+:</span> (<span class="dt">Expr</span> a) 
             <span class="fu">|</span> (<span class="dt">Expr</span> a) <span class="fu">:*:</span> (<span class="dt">Expr</span> a)
             <span class="fu">|</span> (<span class="dt">Expr</span> a) <span class="fu">:^:</span> (<span class="dt">Expr</span> a)
             <span class="fu">|</span> (<span class="dt">Expr</span> a) <span class="fu">:/:</span> (<span class="dt">Expr</span> a)
             <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="ot">sampleExpr ::</span> <span class="dt">Expr</span> <span class="dt">Double</span>
sampleExpr <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">3</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:^:</span> <span class="dt">Const</span> <span class="dv">2</span> <span class="co">--3x^2</span></code></pre></div>
<p>Haskell allows infix operators to act as data constructors, which allows us to express algebraic expressions cleanly and concisely without too much mental parsing. Also note that, since we explicitly defined operator precedence above the data type declaration, we can write expressions without parentheses according to order of operations, like we did in the sample expression.</p>
<h4 id="the-algebra">The Algebra</h4>
<p>Taking derivatives simply by the rules can get messy, so we might as well go ahead and set up an algebra simplification function that cleans up our final expressions for us. This is actually incredibly simple. As long as you know algebraic laws, this kind of thing basically writes itself in Haskell. We just need to pattern match against certain expressions and meld them together according to algebraic law. This function ends up being lengthy long due to the fact that symbolic manipulation is mostly just a bunch of different cases, but we can encode algebraic simplification rules for our above data type in a straightforward way. The following simplify function takes an expression and spits out a simpler one that means the same thing. It’s really just a bunch of pattern-matching cases, so feel free to skim it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simplify ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
simplify (<span class="dt">Const</span> a <span class="fu">:+:</span> <span class="dt">Const</span> b) <span class="fu">=</span> <span class="dt">Const</span> (a <span class="fu">+</span> b)
simplify (a       <span class="fu">:+:</span> <span class="dt">Const</span> <span class="dv">0</span>) <span class="fu">=</span> simplify a
simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:+:</span> a      ) <span class="fu">=</span> simplify a

simplify (<span class="dt">Const</span> a <span class="fu">:*:</span> <span class="dt">Const</span> b) <span class="fu">=</span> <span class="dt">Const</span> (a<span class="fu">*</span>b)
simplify (a <span class="fu">:*:</span> <span class="dt">Const</span> <span class="dv">1</span>)         <span class="fu">=</span> simplify a
simplify (<span class="dt">Const</span> <span class="dv">1</span> <span class="fu">:*:</span> a)         <span class="fu">=</span> simplify a
simplify (a <span class="fu">:*:</span> <span class="dt">Const</span> <span class="dv">0</span>)         <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span>
simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:*:</span> a)         <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span>

simplify (<span class="dt">Const</span> a <span class="fu">:^:</span> <span class="dt">Const</span> b)       <span class="fu">=</span> <span class="dt">Const</span> (a<span class="fu">**</span>b)
simplify (a <span class="fu">:^:</span> <span class="dt">Const</span> <span class="dv">1</span>)             <span class="fu">=</span> simplify a
simplify (a <span class="fu">:^:</span> <span class="dt">Const</span> <span class="dv">0</span>)             <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span>
simplify ((c <span class="fu">:^:</span> <span class="dt">Const</span> b) <span class="fu">:^:</span> <span class="dt">Const</span> a) <span class="fu">=</span> c <span class="fu">:^:</span> (<span class="dt">Const</span> (a<span class="fu">*</span>b))

simplify (<span class="dt">Const</span> a <span class="fu">:*:</span> (<span class="dt">Const</span> b <span class="fu">:*:</span> expr)) <span class="fu">=</span> (<span class="dt">Const</span> <span class="fu">$</span> a<span class="fu">*</span>b) <span class="fu">:*:</span> (simplify expr)
simplify (<span class="dt">Const</span> a <span class="fu">:*:</span> expr <span class="fu">:*:</span> <span class="dt">Const</span> b) <span class="fu">=</span> (<span class="dt">Const</span> <span class="fu">$</span> a<span class="fu">*</span>b) <span class="fu">:*:</span> (simplify expr)
simplify (expr <span class="fu">:*:</span> <span class="dt">Const</span> a <span class="fu">:*:</span> <span class="dt">Const</span> b) <span class="fu">=</span> (<span class="dt">Const</span> <span class="fu">$</span> a<span class="fu">*</span>b) <span class="fu">:*:</span> (simplify expr)
simplify (<span class="dt">Const</span> a <span class="fu">:*:</span> (b <span class="fu">:+:</span> c))        <span class="fu">=</span> (<span class="dt">Const</span> a <span class="fu">:*:</span> (simplify b)) <span class="fu">:+:</span> (<span class="dt">Const</span> a <span class="fu">:*:</span> (simplify c))

simplify (<span class="dt">Const</span> <span class="dv">0</span> <span class="fu">:/:</span> a        ) <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span>
simplify (<span class="dt">Const</span> a <span class="fu">:/:</span> <span class="dt">Const</span> <span class="dv">0</span>)   <span class="fu">=</span> error <span class="st">&quot;Division by zero!&quot;</span>
simplify (<span class="dt">Const</span> a <span class="fu">:/:</span> <span class="dt">Const</span> b)   <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span> <span class="co">-- only when a == b</span>
simplify (a       <span class="fu">:/:</span> <span class="dt">Const</span> <span class="dv">1</span>)   <span class="fu">=</span> simplify a

simplify (a <span class="fu">:/:</span> b)  <span class="fu">=</span> (simplify a) <span class="fu">:/:</span> (simplify b)
simplify (a <span class="fu">:^:</span> b)  <span class="fu">=</span> (simplify a) <span class="fu">:^:</span> (simplify b)
simplify (a <span class="fu">:*:</span> b)  <span class="fu">=</span> (simplify a) <span class="fu">:*:</span> (simplify b)
simplify (a <span class="fu">:+:</span> b)  <span class="fu">=</span> (simplify a) <span class="fu">:+:</span> (simplify b)
simplify x          <span class="fu">=</span> id x

fullSimplify expr <span class="fu">=</span> fullSimplify' expr (<span class="dt">Const</span> <span class="dv">0</span>) <span class="co">-- placeholder</span>
  <span class="kw">where</span> fullSimplify' cur last <span class="fu">|</span> cur <span class="fu">==</span> last <span class="fu">=</span> cur
                               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">let</span> cur' <span class="fu">=</span> simplify cur
                                             <span class="kw">in</span> fullSimplify' cur' cur</code></pre></div>
<p>I’ve also included a <code>fullSimplify</code> function that runs simplify on an expression until the current input matches the last output of simplify (which ensures an expression is completely simplified)*. Note that in the <code>simplify</code> function, I’ve covered a lot of bases, but not all of them. Specifically, division simplification is lacking because it gets complicated quickly and I didn’t want to focus on that in this blog post. We should also note that we don’t have a data type expressing subtraction or negative numbers, so we’ll deal with that now. In order to express the negation of expressions, we define the <code>negate'</code> function, which basically multiplies expressions by <span class="math inline">−1</span> and outputs the resultant expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">negate' ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
negate' (<span class="dt">Var</span> c)    <span class="fu">=</span> (<span class="dt">Const</span> (<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">:*:</span> (<span class="dt">Var</span> c)
negate' (<span class="dt">Const</span> a)  <span class="fu">=</span> <span class="dt">Const</span> (<span class="fu">-</span>a)
negate' (a <span class="fu">:+:</span> b)  <span class="fu">=</span> (negate' a) <span class="fu">:+:</span> (negate' b)
negate' (a <span class="fu">:*:</span> b)  <span class="fu">=</span> (negate' a) <span class="fu">:*:</span> b
negate' (a <span class="fu">:^:</span> b)  <span class="fu">=</span> <span class="dt">Const</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">:*:</span> a <span class="fu">:^:</span> b
negate' (a <span class="fu">:/:</span> b)  <span class="fu">=</span> (negate' a) <span class="fu">:/:</span> b</code></pre></div>
<p>Now we have a relatively robust system for computing symbolic expressions. However, we aren’t able to actually plug anything into these expressions yet, so we’ll fix that now.</p>
<p><em>*Thanks to <a href="http://reddit.com/u/zoells">/u/zoells</a> for the suggestion!</em></p>
<h4 id="evaluating-expressions">Evaluating Expressions</h4>
<p>The first thing we’ll need to do to begin the process of evaluating expressions is write a function to plug in a value for a specific variable. We do this in terms of a function called <code>mapVar</code>, implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mapVar ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
mapVar f (<span class="dt">Var</span> d)   <span class="fu">=</span> f d
mapVar _ (<span class="dt">Const</span> a) <span class="fu">=</span> <span class="dt">Const</span> a
mapVar f (a <span class="fu">:+:</span> b) <span class="fu">=</span> (mapVar f a) <span class="fu">:+:</span> (mapVar f b)
mapVar f (a <span class="fu">:*:</span> b) <span class="fu">=</span> (mapVar f a) <span class="fu">:*:</span> (mapVar f b)
mapVar f (a <span class="fu">:^:</span> b) <span class="fu">=</span> (mapVar f a) <span class="fu">:^:</span> (mapVar f b)
mapVar f (a <span class="fu">:/:</span> b) <span class="fu">=</span> (mapVar f a) <span class="fu">:/:</span> (mapVar f b)

<span class="ot">plugIn ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
plugIn c val <span class="fu">=</span> mapVar (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> c <span class="kw">then</span> <span class="dt">Const</span> val <span class="kw">else</span> <span class="dt">Var</span> x)</code></pre></div>
<p><code>mapVar</code> searches through an expression for a specific variable and performs a function on each instance of that variable in the function. plugIn takes a character and a value, and is defined using <code>mapVar</code> to map variables with a specific name to a constant provided by the user. Now that we have <code>plugIn</code>, we can define two functions: One that takes an expression full of only constants and outputs a result (<code>evalExpr'</code>), and one that will replace a single variable with a constant and output the result (<code>evalExpr</code>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalExpr ::</span> (<span class="dt">Num</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a
evalExpr c x <span class="fu">=</span> evalExpr' <span class="fu">.</span> plugIn c x 

<span class="ot">evalExpr' ::</span> (<span class="dt">Num</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a
evalExpr' (<span class="dt">Const</span> a) <span class="fu">=</span> a
evalExpr' (<span class="dt">Var</span>   c) <span class="fu">=</span> error <span class="fu">$</span> <span class="st">&quot;Variables (&quot;</span>
                              <span class="fu">++</span> [c] <span class="fu">++</span> 
                              <span class="st">&quot;) still exist in formula. Try plugging in a value!&quot;</span>
evalExpr' (a <span class="fu">:+:</span> b) <span class="fu">=</span> (evalExpr' a) <span class="fu">+</span> (evalExpr' b)
evalExpr' (a <span class="fu">:*:</span> b) <span class="fu">=</span> (evalExpr' a) <span class="fu">*</span> (evalExpr' b)
evalExpr' (a <span class="fu">:^:</span> b) <span class="fu">=</span> (evalExpr' a) <span class="fu">**</span> (evalExpr' b)
evalExpr' (a <span class="fu">:/:</span> b) <span class="fu">=</span> (evalExpr' a) <span class="fu">/</span> (evalExpr' b)</code></pre></div>
<p>What we’re doing here is simple. With <code>evalExpr'</code>, we only need to replace our functional types (<code>:+:</code>, <code>:*:</code>, etc) with the actual functions (<code>+</code>, <code>*</code>, etc). When we run into a <code>Const</code>, we simply replace it with it’s inner number value. When we run into a <code>Var</code>, we note that it’s not possible to evaluate, and tell the user that there is still a variable in the expression that needs to be plugged in. With evalExpr, we just plug in a value for a specific variable before evaluating the expression. Simple as that! Here are some examples of expressions and their evaluations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalExpr <span class="ch">'x'</span> <span class="dv">2</span> (<span class="dt">Var</span> <span class="ch">'x'</span>) 
<span class="fu">&gt;</span> <span class="fl">2.0</span> 
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalExpr <span class="ch">'a'</span> <span class="dv">3</span> (<span class="dt">Const</span> <span class="dv">3</span><span class="fu">:+:</span> <span class="dt">Var</span> <span class="ch">'a'</span> <span class="fu">:*:</span> <span class="dt">Const</span> <span class="dv">6</span>)
<span class="fu">&gt;</span>  <span class="fl">21.0</span> 
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalExpr <span class="ch">'b'</span> <span class="dv">2</span> (<span class="dt">Var</span> <span class="ch">'b'</span> <span class="fu">:/:</span> (<span class="dt">Const</span> <span class="dv">2</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'b'</span>)) 
<span class="fu">&gt;</span> <span class="fl">0.5</span> </code></pre></div>
<p>We can even evaluate multivariate expressions using <code>plugIn</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalExpr' <span class="fu">.</span> plugIn <span class="ch">'x'</span> <span class="dv">1</span> <span class="fu">$</span> plugIn <span class="ch">'y'</span> <span class="dv">2</span> (<span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:+:</span> <span class="dt">Var</span> <span class="ch">'y'</span>) 
<span class="fu">&gt;</span> <span class="fl">3.0</span> </code></pre></div>
<p>Now that we’ve extended our symbolic expressions to be able to be evaluated, let’s do what we set out to do – find derivatives!</p>
<h4 id="derivatives">Derivatives</h4>
<p>We aren’t going to get into super-complicated derivatives involving logorithmic or implicit differentiation, etc. Instead, we’ll keep it simple for now, and only adhere to some of the ‘simple’ derivative rules. We’ll need one of them for each of our six expression types: constants, variables, addition, multiplication, division, and exponentiation. We already know the following laws for these from calculus:</p>
<p>——-|—————:<br />
Differentiation of a constant | <span class="math inline">$\frac{d}{dx}k = 0$</span><br />
Differentiation of a variable | <span class="math inline">$\frac{d}{dx}x = 1$</span><br />
Addition differentiation | <span class="math inline">$\frac{d}{dx}\left(f(x) + g(x)\right) = \frac{d}{dx}f(x) +\frac{d}{dx}g(x)$</span><br />
Power rule (/chain rule) | <span class="math inline">$\frac{d}{dx}f(x)^n = nf(x)^{n-1} \cdot \frac{d}{dx}f(x)$</span><br />
Product rule | <span class="math inline">$\frac{d}{dx}\left(f(x) \cdot g(x)\right) = \frac{d}{dx}f(x) \cdot g(x) + f(x) \cdot \frac{d}{dx}g(x)$</span><br />
Quotient rule | <span class="math inline">$\frac{d}{dx}\frac{f(x)}{g(x)} = \frac{\frac{d}{dx}f(x) \cdot g(x) - \frac{d}{dx}g(x) \cdot f(x)}{g(x)^2}$</span></p>
<p>As it turns out, we can almost directly represent this in Haskell. There should be no surprises here – following along with the above rules, it is relatively easy to see how this function calculates derivatives. We will still error out if we get something like <span class="math inline"><em>x</em><sup><em>x</em></sup></span> as input, as it will require a technique we haven’t implemented yet. However, this will suffice for a many different expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">derivative ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
derivative (<span class="dt">Var</span> c)           <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">1</span>
derivative (<span class="dt">Const</span> x)         <span class="fu">=</span> <span class="dt">Const</span> <span class="dv">0</span>

<span class="co">--product rule (ab' + a'b)</span>
derivative (a <span class="fu">:*:</span> b)         <span class="fu">=</span> (a <span class="fu">:*:</span> (derivative b)) <span class="fu">:+:</span>  (b <span class="fu">:*:</span> (derivative a)) <span class="co">-- product rule</span>

 <span class="co">--power rule (xa^(x-1) * a')</span>
derivative (a <span class="fu">:^:</span> (<span class="dt">Const</span> x)) <span class="fu">=</span> ((<span class="dt">Const</span> x) <span class="fu">:*:</span> (a <span class="fu">:^:</span> (<span class="dt">Const</span> <span class="fu">$</span> x<span class="fu">-</span><span class="dv">1</span>))) <span class="fu">:*:</span> (derivative a)
derivative (a <span class="fu">:+:</span> b)         <span class="fu">=</span> (derivative a) <span class="fu">:+:</span> (derivative b)

 <span class="co">-- quotient rule ( (a'b - b'a) / b^2 )</span>
derivative (a <span class="fu">:/:</span> b)         <span class="fu">=</span> ((derivative a <span class="fu">:*:</span> b) <span class="fu">:+:</span> (negate' (derivative b <span class="fu">:*:</span> a))) 
                               <span class="fu">:/:</span> 
                               (b <span class="fu">:^:</span> (<span class="dt">Const</span> <span class="dv">2</span>))
derivative expr              <span class="fu">=</span> error <span class="st">&quot;I'm not a part of your system!&quot;</span> <span class="co">-- unsupported operation</span>

<span class="ot">ddx ::</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
ddx <span class="fu">=</span> fullSimplify <span class="fu">.</span> derivative  

<span class="ot">ddxs ::</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> [<span class="dt">Expr</span> a]
ddxs <span class="fu">=</span> iterate ddx

<span class="ot">nthDerivative ::</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
nthDerivative n <span class="fu">=</span> foldr1 (<span class="fu">.</span>) (replicate n ddx)</code></pre></div>
<p>So, what can we do with this? Well, let’s take a look:</p>
<p>The first, most obvious thing we’ll note when running the derivative function on an expression is that what it produces is rather ugly. To fix this, we’ll write a function ddx that will simplify the derivative expression three times to make our output cleaner. (Remember <code>sampleExpr</code> = <span class="math inline">3<em>x</em><sup>2</sup></span>)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> derivative sampleExpr 
<span class="fu">&gt;</span> <span class="dt">Const</span> <span class="fl">3.0</span> <span class="fu">:*:</span> ((<span class="dt">Const</span> <span class="fl">2.0</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:^:</span> <span class="dt">Const</span> <span class="fl">1.0</span>) <span class="fu">:*:</span> <span class="dt">Const</span> <span class="fl">1.0</span>) <span class="fu">:+:</span> <span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:^:</span> <span class="dt">Const</span> <span class="fl">2.0</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> ddx sampleExpr 
<span class="fu">&gt;</span> <span class="dt">Const</span> <span class="fl">6.0</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'x'</span> <span class="co">-- 6x</span></code></pre></div>
<p>Another thing we can do is get a list of derivatives. The <code>iterate</code> method from the <code>Prelude</code> suits this type of thing perfectly – we can generate a (infinite!) list of derivatives of a function just by calling <code>iterate ddx</code>. Simple, expressive, and incredibly powerful.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> take <span class="dv">3</span> <span class="fu">$</span> ddxs
sampleExpr [<span class="dt">Const</span> <span class="fl">3.0</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:</span>\<span class="fu">^:</span> <span class="dt">Const</span> <span class="fl">2.0</span>,<span class="dt">Const</span> <span class="fl">6.0</span> <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'x'</span>,<span class="dt">Const</span> <span class="fl">6.0</span>] <span class="co">-- [3x\^2, 6x, 6] </span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="kw">let</span> ds <span class="fu">=</span> take <span class="dv">4</span> <span class="fu">$</span> ddxs sampleExpr
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> fmap (evalExpr <span class="ch">'x'</span> <span class="dv">2</span>) ds 
<span class="fu">&gt;</span> [<span class="fl">12.0</span>,<span class="fl">12.0</span>,<span class="fl">6.0</span>,<span class="fl">0.0</span>] </code></pre></div>
<p>We’re also able to grab the <span class="math inline"><em>n</em><sup><em>t</em><em>h</em></sup></span> derivative of an expression. We could simply grab the <span class="math inline"><em>n</em><sup><em>t</em><em>h</em></sup></span> term of <code>ddxs</code>, but we’ll do it without the wasted memory by repeatedly composing <code>ddx</code> <span class="math inline"><em>n</em></span> times using <code>foldr1</code> and <code>replicate</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> nthDerivative <span class="dv">2</span> sampleExpr 
<span class="fu">&gt;</span> <span class="dt">Const</span> <span class="fl">6.0</span></code></pre></div>
<p>There’s one last thing I want to touch on. Since it’s so simple to generate a list of derivatives of a function, why not use that to build functions’ Taylor series expansions?</p>
<h4 id="taylor-series-expansions">Taylor Series Expansions</h4>
<p>The Taylor series expansion of a function <span class="math inline"><em>f</em>(<em>x</em>)</span> about <span class="math inline"><em>a</em></span> is defined as follows: <br /><span class="math display">$$ \sum{n=1}^{\infty} \frac{f^{(n)}(a)}{n!} \cdot (x -
a)^n $$</span><br /> The Maclaurin series expansion for a function is the Taylor series of a function with a = 0, and we will also implement that. Given that we can:</p>
<ol style="list-style-type: decimal">
<li>Have multivariate expressions</li>
<li>Easily generate a list of derivatives</li>
</ol>
<p>We can actually find the Taylor series expansion of a function easily. Again, we can almost directly implement this function in Haskell, and evaluating it is no more difficult.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">taylor ::</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> [<span class="dt">Expr</span> a]
taylor expr <span class="fu">=</span> fmap fullSimplify (fmap series exprs)
  <span class="kw">where</span> indices <span class="fu">=</span> fmap fromIntegral [<span class="dv">1</span><span class="fu">..</span>]
        derivs  <span class="fu">=</span> fmap (changeVars <span class="ch">'a'</span>) (ddxs expr)
          <span class="kw">where</span> changeVars c <span class="fu">=</span> mapVar (\_ <span class="ot">-&gt;</span> <span class="dt">Var</span> c)
        facts   <span class="fu">=</span> fmap <span class="dt">Const</span> <span class="fu">$</span> scanl1 (<span class="fu">*</span>) indices
        exprs   <span class="fu">=</span> zip (zipWith (<span class="fu">:/:</span>) derivs facts) indices <span class="co">-- f^(n)(a)/n!</span>
        series (expr, n) <span class="fu">=</span> 
          expr <span class="fu">:*:</span> ((<span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:+:</span> (negate' <span class="fu">$</span> <span class="dt">Var</span> <span class="ch">'a'</span>)) <span class="fu">:^:</span> <span class="dt">Const</span> n) <span class="co">-- f^(n)(a)/n! * (x - a)^n</span>

maclaurin <span class="fu">=</span> fmap (fullSimplify <span class="fu">.</span> plugIn <span class="ch">'a'</span> <span class="dv">0</span>) <span class="fu">.</span> taylor 

evalTaylorWithPrecision a x prec <span class="fu">=</span>  
  sum <span class="fu">.</span> map (evalExpr' <span class="fu">.</span> plugIn <span class="ch">'x'</span> x <span class="fu">.</span> plugIn <span class="ch">'a'</span> a) <span class="fu">.</span> take prec <span class="fu">.</span> taylor

evalTaylor a x <span class="fu">=</span> evalTaylorWithPrecision a x <span class="dv">100</span>
        
evalMaclaurin <span class="fu">=</span> evalTaylor <span class="dv">0</span>
evalMacLaurinWithPrecision <span class="fu">=</span> evalTaylorWithPrecision <span class="dv">0</span></code></pre></div>
<p>To produce a Taylor series, we need a couple of things:</p>
<ul>
<li>A list of derivatives</li>
<li>A list of indices</li>
<li>A list of factorials</li>
</ul>
<p>We create these three things in where clauses in the taylor declaration. indices are simple, <code>derivs</code> calculates a list of derivatives (using <code>mapVar</code> again to change all variables into <span class="math inline"><em>a</em></span>s), and <code>facts</code> contains our factorials wrapped in <code>Const</code>s. We generate a list of <code>(expression, index)</code>s in <code>exprs</code>, and then map the “gluing” function <code>series</code> over <code>exprs</code> to produce a list of expressions in the series expansion. We then <code>fmap superSimplify</code> over the list in order to simplify down our expressions, and we get back a list of Taylor series terms for the given expression. The Maclaurin expansion can be defined as mentioned above in terms of the Taylor series, and again, we basically directly encode it (though we do have to re-simplify our expressions due to the plugging in of a variable). Let’s take a look at the Taylor expansion for <span class="math inline"><em>f</em>(<em>x</em>)=<em>x</em></span>. We note that: <span class="math inline"><em>f</em>(<em>a</em>)=<em>a</em></span>, <span class="math inline"><em>f</em>′(<em>a</em>)=1</span>, <span class="math inline"><em>f</em>″(<em>a</em>)=0</span>, and the rest of the derivatives will be 0. So our Taylor series terms <span class="math inline"><em>T</em><sub><em>n</em></sub></span> should look something like: <span class="math inline">$T_1 = \frac{a}{1} \cdot (x - a) = a \cdot (x-a)$</span> <span class="math inline">$T_2 = \frac{1}{2} \cdot (x-a)^2$</span> <span class="math inline">$T_3 = \frac{0}{6} \cdot (x-a)^3 = 0$</span> …and so on. Let’s take a look at what <code>taylor</code> produces:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> take <span class="dv">3</span> <span class="fu">$</span> taylor (<span class="dt">Var</span> <span class="ch">'x'</span>) 
<span class="fu">&gt;</span> [<span class="dt">Var</span> <span class="ch">'a'</span> <span class="fu">:*:</span> (<span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:+:</span> <span class="dt">Const</span> (<span class="fu">-</span><span class="fl">1.0</span>) <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'a'</span>), 
<span class="fu">--^</span> a <span class="fu">*</span> (x<span class="fu">-</span>a) 
(<span class="dt">Const</span> <span class="fl">1.0</span> <span class="fu">:/:</span> <span class="dt">Const</span> <span class="fl">2.0</span>) <span class="fu">:*:</span> (<span class="dt">Var</span> <span class="ch">'x'</span> <span class="fu">:+:</span> <span class="dt">Const</span> (<span class="fu">-</span><span class="fl">1.0</span>) <span class="fu">:*:</span> <span class="dt">Var</span> <span class="ch">'a'</span>) <span class="fu">:^:</span> <span class="dt">Const</span> <span class="fl">2.0</span>, 
<span class="fu">--^</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">2</span> <span class="fu">*</span> (x<span class="fu">-</span>a)<span class="fu">^</span><span class="dv">2</span> 
<span class="dt">Const</span> <span class="fl">0.0</span>] </code></pre></div>
<p>This matches what we determined earlier. To evaluate a Taylor expression, we need a value for <span class="math inline"><em>a</em></span>, a value for <span class="math inline"><em>x</em></span>, and a specified number of terms for precision. We default this precision to 100 terms in the <code>evalTaylor</code> function, and the logic takes place in the <code>evalTaylorWithPrecision</code> function. In this function, we get the Taylor expansion, take the first <code>prec</code> terms, plug in <code>a</code> and <code>x</code> for all values of the function, and finally sum the terms. Maclaurin evaluation is again defined in terms of Taylor evaluation.</p>
<p>Taking a look at the above Taylor series expansion of <span class="math inline"><em>f</em>(<em>x</em>)=<em>x</em></span>, there is only one term where a zero-valued <span class="math inline"><em>a</em></span> will produce any output (namely <span class="math inline">$\frac{1}{2} \cdot (x-a)^2$</span>). So when we evaluate our Maclaurin series for this function at x, we should simply get back <span class="math inline">$\frac{1}{2}x^2$</span>. Let’s see how it works:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalMaclaurin <span class="dv">2</span> (<span class="dt">Var</span> <span class="ch">'x'</span>) 
<span class="fu">&gt;</span> <span class="fl">2.0</span> <span class="co">--1/2 2\^2 = 1/2 * 4 = 2 </span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalMaclaurin <span class="dv">3</span> (<span class="dt">Var</span> <span class="ch">'x'</span>) 
<span class="fu">&gt;</span> <span class="fl">4.5</span> <span class="co">-- 1/2 * 3^2 = 1/2 * 9 = 4.5 </span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> evalMaclaurin <span class="dv">10</span> (<span class="dt">Var</span> <span class="ch">'x'</span>) 
<span class="fu">&gt;</span> <span class="fl">50.0</span> <span class="co">-- 1/2 * 10^2 = 1/2 * 100 = 50 </span></code></pre></div>
<p>Until next time,</p>
<p>Ben</p>
</div>
</p>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'abstract-nonsense'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

      </section>
      <footer class="footer">
        © 2016 Benjamin Kovach
        <br />
        Site proudly generated by <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
      </footer>
    </div>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53651640-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script>
      lightbox.option({
        resizeDuration: 200,
      })
    </script>
  </body>
</html>
