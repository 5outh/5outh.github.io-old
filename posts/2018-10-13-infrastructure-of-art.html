<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Benjamin Kovach</title>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="stylesheet" type="text/css" href="../css/site.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../js/lightbox2/dist/css/lightbox.min.css" />
    <script type="text/javascript" src="../js/lightbox2/dist/js/lightbox-plus-jquery.js"></script>
    <script type="text/javascript" src="../js/site.js?v=3"></script>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  </head>
  <body style="margin-left: auto; margin-right: auto; display: block; max-width:800px">
    <div id="left"></div>
    <div class="wrapper">
      <header>
        <ul id="nav">
    <li><a href="../">Home</a></li>
    <li><a href="http://shop.kovach.me/">Shop</a></li>
    <li><a href="../art.html">Selected Artwork</a></li>
    <li><a href="../contact.html">About</a></li>
    <li><a href="../atom.xml">Atom</a>/<a href="../rss.xml">RSS</a></li>
</ul>


        <h3 id="blog_title">Benjamin Kovach</h3>
      </header>
      <section>
        
          <h4 class="post-title">Tips for Generative Infrastructure and Tooling</h4>
        
        <p>
<div class="post_body">
  <center>
<img width="100%" src="https://assets.bigcartel.com/product_images/224876428/1539201462748-20.0.png?auto=format&fit=max&w=1540" /> <i>oigiesines-t</i>
</center>
<p>Like with any programming project, certain aspects of generating artwork can become repetitive or difficult over time. I want to discuss some infrastructure/tooling related utilities that I‚Äôve built around my art generation process to make it easier to work with. This post is language-agnostic in the sense that these ideas should be portable between different stacks. Example code is presented in Haskell and zsh, but I aim to explain these concepts well enough that the code doesn‚Äôt matter all that much.</p>
<h3 id="rendering-new-images-on-any-source-change">Rendering new images on any source change</h3>
<p>When I make a change in a file, I expect to see the result of that change as soon as possible, without doing anything extra. That is a philosophy I stand by in all of my programming work, for the most part:</p>
<ul>
<li>Code should re-compile when it changes</li>
<li>Any relevant tests should re-run when code changes (if I am currently testing)</li>
<li>A new image should be rendered when sketch source code changes</li>
</ul>
<p>One language-agnostic tool for achieving this file-watching capability is <a href="http://www.entrproject.org/">entr</a>. There are other file watchers out there, but this one has been reliable for me. Given a program <code>generate-art</code> that generates a new image, it can be used like this:</p>
<pre class="sh"><code>$ ls &lt;source files&gt; | entr generate-art</code></pre>
<p><code>&lt;source files&gt;</code> for me is <code>**/*.hs</code> in <code>zsh</code> - all Haskell files in the current directory. When any of those files are changed, a new image is re-rendered.</p>
<h3 id="organizing-images">Organizing images</h3>
<p>‚Ä¶but, we don‚Äôt just want one image. It‚Äôs much better to have a snapshot of <strong>every single image that has ever been rendered</strong> so we can pick and choose our favorites and look back at how far we‚Äôve come. We must organize.</p>
<p>My image organization technique is super simple. I store images in the following directory heirarchy: <code>images/&lt;name&gt;/&lt;seed&gt;.png</code>, where</p>
<ul>
<li><code>&lt;name&gt;</code> is the name of the piece I am currently working on. This is often something nebulous like <code>sketch4</code> while I‚Äôm messing around. Once a process starts to take shape, I change the name to something more concrete.</li>
<li><code>&lt;seed&gt;</code> is a UNIX Timestamp. When developing sketches, the current UNIX Timestamp is used as a seed, so a natural linear order is established within each folder.</li>
</ul>
<p>Additionally, a single file <code>latest.png</code> is created and overwritten on save in each folder. This allows me to leave <code>latest.png</code> open in an (auto-reloading) image viewer, and see any changes automatically.</p>
<h3 id="controlling-variables">Controlling variables</h3>
<p>My art generation program has a thin CLI wrapper which I use to control certain variables. Here‚Äôs the help text as an overview:</p>
<pre class="shell"><code>$ drawing-hs --help
drawing-hs

Usage: drawing-hs [--seed SEED] [--scale SCALE] [--width WIDTH]
                  [--height HEIGHT] [--times TIMES] [--name NAME]
                  [-r|--render-progress] [-v|--render-video]
                  [--metadata METADATA]
  Generate art

Available options:
  -h,--help                Show this help text</code></pre>
<p>This is tremendously useful and not particularly difficult behavior to achieve. Here are some example scenarios that have made this absolutely invaluable:</p>
<p><br /></p>
<p>I am generating a process that is kind of chaotic, but I like some of the outputs a lot. I turn on the flag <code>--times=100</code> to render 100 random images instead of just one.</p>
<hr width="11%" />
<p><br /></p>
<p>I am working on a piece that is kind of slow to render, especially with a large image size. I turn down the flag <code>--scale=10</code> to <code>--scale=5</code> to speed up the rendering until I am happier with the process.</p>
<hr width="11%" />
<p><br /></p>
<p>I have generated hundreds of images and have picked out one that I like a lot. I can set the seed using the <code>--seed</code> flag, along with a large scale using the <code>--scale</code> flag to generate the large version for printing.</p>
<hr width="11%" />
<p><br /></p>
<p>I have found a particular seed I like a lot, but don‚Äôt really like the color palette I was using. I can set the <code>--seed</code> flag to lock the seed and tweak non-random components of the program (in this instance, the color palette).</p>
<hr width="11%" />
<p><br /></p>
<p>I have decided that my <code>sketch</code> is good enough to be named. I pass in the <code>--name</code> flag to start saving my files in a new location for polishing and better organization.</p>
<hr width="11%" />
<p>Extremely useful stuff. We‚Äôll talk about <code>--render-progress</code> and <code>--render-video</code> later.</p>
<h3 id="recovering-lost-sketches">Recovering lost sketches</h3>
<p>Here‚Äôs a short story. One day, I was iterating on a process and posted a work in progress image to twitter. <a href="http://www.tylerlhobbs.com">Tyler Hobbs</a> expressed interest in a print swap with that work-in-progress image. Hell yeah, I thought! Sounds awesome.</p>
<p>Unfortunately, I had iterated on that particular sketch a bit after posting. The original image I had posted was not large enough to print, and I had no way of pairing up the seed used to generate the image with the code that actually generated it. I was able to recover it mostly, but the colors were not quite the same as the image I posted on twitter, and it took a ton of effort to even partially recover it. This really bothered me. Ultimately, we still swapped prints, which was a wonderful experience. But I knew I had to fix the problem of unrecoverable works in progress.</p>
<center>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="und" dir="ltr">
<a href="https://twitter.com/hashtag/generative?src=hash&amp;ref_src=twsrc%5Etfw">#generative</a> <a href="https://t.co/P80WvehjcW">pic.twitter.com/P80WvehjcW</a>
</p>
‚Äî Ben (<span class="citation">@BendotK</span>) <a href="https://twitter.com/BendotK/status/984413805617795072?ref_src=twsrc%5Etfw">April 12, 2018</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<i>The infamous unrecoverable sketch</i>
</center>
<p>Here‚Äôs what I did:</p>
<ul>
<li>Create a completely new git repository in a separate location. I call it <code>sketch</code>.</li>
<li>Whenever the program runs, copy the source code from the ‚Äúreal‚Äù drawing project to the <code>sketch</code> folder.</li>
<li>Automatically create a git commit with the name of the <code>seed</code> in it.</li>
</ul>
<p>This is implemented as a hook that runs after each image is generated. The script <code>save_sketch</code> looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#! /bin/zsh</span>

<span class="co"># Copy all source files to the sketch directory, overwriting anything that's</span>
<span class="co"># already there</span>
<span class="kw">cp</span> -R src/ ../sketch
<span class="kw">cd</span> ../sketch

<span class="co"># Create a git commit with the provided message, allowing empty commits in case</span>
<span class="co"># no code was actually changed (allowing the reference of multiple sketches from</span>
<span class="co"># the same code, with different seeds)</span>
<span class="kw">git</span> add . -A
<span class="kw">git</span> commit -m <span class="st">&quot;</span><span class="ot">$1</span><span class="st">&quot;</span> --allow-empty</code></pre></div>
<p>And in my Haskell code, I have this little function that runs as a part of the image generation process:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">saveSketch ::</span> <span class="dt">Generate</span> ()
saveSketch <span class="fu">=</span> <span class="kw">do</span>
  seed <span class="ot">&lt;-</span> asks worldSeed
  liftIO <span class="fu">$</span> <span class="kw">do</span>
    (code, out, _) <span class="ot">&lt;-</span> readProcessWithExitCode
      <span class="st">&quot;./scripts/save_sketch.sh&quot;</span>
      [<span class="st">&quot;Automated publish; Seed: &quot;</span> <span class="fu">&lt;&gt;</span> show seed]
      <span class="st">&quot;&quot;</span>
    putStrLn <span class="fu">$</span> show code <span class="fu">&lt;&gt;</span> <span class="st">&quot; // &quot;</span> <span class="fu">&lt;&gt;</span> out</code></pre></div>
<p>For readers not fluent in Haskell, this basically means ‚Äúget the current seed and call <code>./scripts.save_sketch.sh</code> with a commit message containing it‚Äù.</p>
<p>Now, recovering sketches is just a matter of reaching into that repository and copying it to the working directory:</p>
<div class="sourceCode"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span class="co">#! /bin/zsh</span>

<span class="co"># Make sure we want to override the current source tree, since this is a</span>
<span class="co"># destructive operation</span>
<span class="kw">read</span> -q <span class="st">&quot;RELOAD?Are you sure you want to restore history to (</span><span class="ot">$1</span><span class="st">)? &quot;</span> -n 1 -r
<span class="kw">echo</span>

<span class="kw">if [[</span> <span class="ot">$RELOAD</span> =~ ^[Yy]$<span class="kw"> ]]</span>
<span class="kw">then</span>
  <span class="kw">cd</span> ../sketch

  <span class="co"># Check out the git hash with the matching seed in &quot;sketch&quot; repository,</span>
  <span class="co"># then copy it over to the &quot;real&quot; repository destructively. Afterwards,</span>
  <span class="co"># switch back to the `master` branch of the &quot;sketch&quot; repository.</span>
  <span class="ot">COMMIT_HASH=$(</span>git --no-pager <span class="kw">log</span> --grep <span class="st">&quot;</span><span class="ot">$1</span><span class="st">&quot;</span> --pretty=format:<span class="st">&quot;%h&quot;</span><span class="ot">)</span>
  git checkout <span class="ot">$COMMIT_HASH</span>

  <span class="kw">echo</span> <span class="st">&quot;Overwriting drawing-hs source...&quot;</span>
  <span class="kw">cp</span> -R src ../drawing-hs/src/

  <span class="kw">echo</span> <span class="st">&quot;Resetting to master branch...&quot;</span>
  git checkout master
<span class="kw">else</span>
  <span class="kw">echo</span> <span class="st">&quot;Aborting due to negative confirmation.&quot;</span>
<span class="kw">fi</span></code></pre></div>
<p>This has not only been useful for situations like the print swap, but also for iterative work. Sometimes, I go too far in one direction, look back and realize I liked a previous iteration better. These scripts allow me to reset my progress back to any previous state, which has the additional psychological side-effect of pushing my work forward without fear of loss.</p>
<h3 id="rendering-video">Rendering video</h3>
<p>My graphics framework doesn‚Äôt allow native creation of videos. Instead, I render a bunch of intermediate images with a specified format, then pass those into <code>ffmpeg</code> to create an mp4. To do this, a few things are needed:</p>
<ul>
<li>A global counter, to track the frame number that is currently being rendered</li>
<li>A way of formatting ints with a specific amount of padding (I use 8 digits)</li>
<li>ffmpeg, of course</li>
</ul>
<p>I have a utility function called <code>renderProgress</code> that renders a single png with the surface that is currently being drawn. I can litter my program with calls to <code>renderProgress</code> - often in loops - to render a given frame with the appropriate index. This stores images in the folder <code>./images/&lt;name&gt;/progress/&lt;seed&gt;/&lt;index&gt;.png</code>, where <code>&lt;index&gt;</code> is a frame index, padded with 8s to 8 digits. For example:</p>
<pre><code>$ ls -l images/example_sketch/progress/1539455256091/
total 72464
-rw-r--r-- 1 bendotk bendotk   5386 Oct 13 14:27 00000000.png
-rw-r--r-- 1 bendotk bendotk  10806 Oct 13 14:27 00000001.png
-rw-r--r-- 1 bendotk bendotk  15926 Oct 13 14:27 00000002.png
-rw-r--r-- 1 bendotk bendotk  21065 Oct 13 14:27 00000003.png
-rw-r--r-- 1 bendotk bendotk  25998 Oct 13 14:27 00000004.png
-rw-r--r-- 1 bendotk bendotk  30582 Oct 13 14:27 00000005.png
-rw-r--r-- 1 bendotk bendotk  35103 Oct 13 14:27 00000006.png
-rw-r--r-- 1 bendotk bendotk  36306 Oct 13 14:27 00000007.png
-rw-r--r-- 1 bendotk bendotk  34001 Oct 13 14:27 00000008.png
-rw-r--r-- 1 bendotk bendotk  34423 Oct 13 14:27 00000009.png
-rw-r--r-- 1 bendotk bendotk  35280 Oct 13 14:27 00000010.png
-rw-r--r-- 1 bendotk bendotk  37135 Oct 13 14:27 00000011.png
# ... and so on</code></pre>
<p>Progress is only rendered if the <code>--render-progress</code> CLI flag is turned on; this allows me to conditionally turn off intermediate rendering (which is slow) without having to manually remove a bunch of function calls from my program.</p>
<p>In order to turn these frames into a video, I use a little wrapper around <code>ffmpeg</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#! /bin/zsh</span>

<span class="co"># Arguments:</span>
<span class="co"># $1: name of the sketch</span>
<span class="co"># $2: seed of the sketch</span>
<span class="co"># $3: desired frame rate</span>

<span class="co"># Location of the eventual video file</span>
<span class="ot">VIDEO_FILE=</span><span class="st">&quot;./images/</span><span class="ot">$1</span><span class="st">/progress/</span><span class="ot">$2</span><span class="st">/progress.mp4&quot;</span>

<span class="co"># Use ffmpeg to create a video from the images in &quot;images/$1/progress/$2/&quot;</span>
<span class="co"># in sequential order</span>
<span class="kw">ffmpeg</span> -y -r <span class="ot">$3</span> -f image2 -s 640x640 \
  -i images/<span class="ot">$1</span>/progress/<span class="ot">$2</span>/%08d.png -b:v 1024 \
  -vcodec libx264 -crf 25 -pix_fmt yuv420p <span class="ot">$VIDEO_FILE</span>

<span class="co"># Remove intermediate frames after video has been rendered</span>
<span class="kw">rm</span> ./images/<span class="ot">$1</span>/progress/<span class="ot">$2</span>/*.png

<span class="co"># Open the video file after it has completed rendering.</span>
<span class="kw">xdg-open</span> <span class="ot">$VIDEO_FILE</span></code></pre></div>
<p>This script is called with the appropriate arguments from within the image rendering program if the <code>--render-video</code> option is supplied. I use a hard-coded frame rate of 30 frames per second within the application, but occasionally I will override that, so it is useful to retain as a command line flag. <code>ffmpeg</code> is largely a mystery to me, so a lot of these options have been picked up after troubleshooting and completely forgotten about after I got it working.</p>
<h3 id="wrapping-up">Wrapping up</h3>
<p>These things have saved me a lot of time and pain with a bit of fiddling around. Feel free to <a href="https://twitter.com/BendotK">ping me on twitter</a> if you have any questions or comments. üçª</p>
</div>

</p>
      </section>
      <footer class="footer">
        ¬© 2018 Benjamin Kovach
        <br />
        Site proudly generated by <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
      </footer>
    </div>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53651640-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script>
      lightbox.option({
        resizeDuration: 200,
      })
    </script>
  </body>
</html>
