<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Abstract Nonsense</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css">
  </head>
  <body>
    <div id="left"></div>
    <div class="wrapper">
      <header>
        <ul id="nav">
    <li><a href="../">Home</a></li>
    <li><a href="../contact.html">About</a></li>
</ul>


        <h1 id="blog_title">Abstract Nonsense</h1>
      </header>
      <section>
        
          <h3 class="post-title">Monoids in Theory and in Haskell</h3>
        
        <p>
<div class="post_body">
	<h2 id="overview">Overview</h2>
<p>This is the second in a series of posts about category theory and its relationship with Haskell. We’ll be exploring monoids in this post!</p>
<h2 id="the-monoid-intuitively">The monoid (intuitively)</h2>
<p>A monoid is a mathematical object, just like a category, <a href="http://localhost:8000/posts/2016-06-01-categories.html">which we explored in the last post</a>. Intuitively, a monoid is a structure which encodes the ability to concatenate two things, and a zero-like element which, when used in concatenation, does not affect the other element. Let’s look at a typical mathematical formulation of a monoid:</p>
<p>A <strong>monoid</strong> is a set <span class="math inline"><em>M</em></span> equipped with a binary operation <span class="math inline">× : <em>m</em> → <em>m</em> → <em>m</em></span> and a special element <span class="math inline">1 ∈ <em>M</em></span> such that <span class="math inline">1</span> and <span class="math inline">×</span> satisfy the following laws:</p>
<ul>
<li>Associativity: <span class="math inline">(<em>x</em> × <em>y</em>)×<em>z</em> = <em>x</em> × (<em>y</em> × <em>z</em>)</span></li>
<li>Left and right unit laws: <span class="math inline">1 × <em>x</em> = <em>x</em> = <em>x</em> × 1</span></li>
</ul>
<p>I wouldn’t be surprised at this point if, even without a heavy mathematical background, one could come up with an example of a monoid. Let’s look at a couple.</p>
<p>The monoid <span class="math inline">{ℝ, ×, 1}</span> is an obvious example of a monoid; that is, our set <span class="math inline"><em>M</em></span> is the <strong>real numbers</strong>, our binary operation is <strong>multiplication</strong>, and our <span class="math inline">1</span> element is the number <strong>1</strong>.</p>
<p>Another example of a monoid on numeric values is <span class="math inline">{ℤ, +, 0}</span>; the <strong>integers</strong> under <strong>addition</strong> with <span class="math inline">1</span> being <strong>0</strong>.</p>
<p>In the programming world, monoids show up all over the place as well. A well-known monoid, using haskell syntax, is <code>{[a], (++), []}</code> – the monoid of <strong>lists</strong> under <strong>concatentation</strong> with <span class="math inline">1</span> being the <strong>empty list</strong>.</p>
<h2 id="the-monoid-in-haskell">The monoid (in haskell)</h2>
<p>As a haskell programmer, the aforementioned definition for a monoid looks awfully familiar. The typeclass for <code>Monoid</code> looks almost the exact same, sans axioms, and modulo names, as the traditional mathematical formulation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span>
<span class="ot">  mempty ::</span> m <span class="co">-- Analogous to 1</span>
<span class="ot">  mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="co">-- Analogous to our binary operation </span></code></pre></div>
<p>We can even encode the three examples of monoids mentioned above in a very straightforward way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Let's pretend Floats are the reals </span>
<span class="co">-- {R, *, 1}</span>
<span class="kw">newtype</span> <span class="dt">Product</span> <span class="fu">=</span> <span class="dt">Product</span>{<span class="ot"> runProduct ::</span> <span class="dt">Float</span> }

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Product</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Product</span> <span class="dv">1</span>
  mappend (<span class="dt">Product</span> a) (<span class="dt">Product</span> b) <span class="fu">=</span> <span class="dt">Product</span> (a <span class="fu">*</span> b)

<span class="co">-- {Z, +, 0}</span>
<span class="kw">newtype</span> <span class="dt">Sum</span> <span class="fu">=</span> <span class="dt">Sum</span>{<span class="ot"> runSum ::</span> <span class="dt">Integer</span> }

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Sum</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span>
  mappend (<span class="dt">Sum</span> a) (<span class="dt">Sum</span> b) <span class="fu">=</span> <span class="dt">Sum</span> (a <span class="fu">+</span> b)

<span class="co">-- This one is defined in the Prelude</span>
<span class="co">-- {[a], ++, []}</span>
<span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span>
  mempty <span class="fu">=</span> []
  mappend xs ys <span class="fu">=</span> xs <span class="fu">++</span> ys</code></pre></div>
<p>We have to verify that our instances follow the laws, which translated to haskell look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Associativity</span>
(a <span class="ot">`mappend`</span> b) <span class="ot">`mappend`</span> c <span class="fu">==</span> a <span class="ot">`mappend`</span> (b <span class="ot">`mappend`</span> c)

<span class="co">-- Left/right unit laws</span>
mempty <span class="ot">`mappend`</span> a <span class="fu">==</span> a <span class="fu">==</span> a <span class="ot">`mappend`</span> mempty</code></pre></div>
<p>It is not so hard to reason through these laws for the instances listed above.</p>
<h2 id="the-monoid-in-category-theory">The monoid (in category theory)</h2>
<p>We’re not done quite yet, because category theorists have picked up on a quaint definition of a monoid:</p>
<blockquote>
<p>A <strong>monoid</strong> is a category with one object.</p>
</blockquote>
<blockquote>
<p>~ <a href="http://www.springer.com/us/book/9780387984032">Mac Lane, 1978</a></p>
</blockquote>
<p>Well, that’s convenient. But what is really going on here? Let’s look at a visual representation of the category theory interpretation of <span class="math inline">{ℤ, +, 0}</span> that we saw before*:</p>
<p><img src="../images/monoid.png" style="width:350px" class="center-block"></p>
<p><small>* The image gets a little messy with the negatives, but those are valid arrows as well.</small></p>
<p>Morphisms in our category are elements of <span class="math inline">ℤ</span>. This can be confusing if we have some expectation about the way arrows should look. But, recall that to define a morphism, we only need to be able to assign a source and target to them, which are totally abstract concepts. Our set of morphisms is then exactly <span class="math inline">ℤ</span>, where we just pick the same source and target for every single element.</p>
<p><span class="math inline"><em>i</em><em>d</em></span> is the arrow labeled <span class="math inline">0</span>:</p>
<p><img src="../images/morphisms_0.png" style="width:350px" class="center-block"></p>
<p>Here are two more arrows:</p>
<p><img src="../images/morphisms_1.png" style="width:350px" class="center-block"></p>
<p>Composing these arrows gives us something that looks like this, intuitively:</p>
<p><img src="../images/morphisms_2.png" style="width:350px" class="center-block"></p>
<p>Composition is addition, so this is equivalent to:</p>
<p><img src="../images/morphisms_3.png" style="width:350px" class="center-block"></p>
<p>An important thing to note here is that <strong>the object doesn’t really matter</strong>. The above diagrams should make sense regardless of what the source and target of the arrows are, as long as they’re the same thing. Further, the source and target must be the same so we can compose freely. If they weren’t, we wouldn’t be guaranteed to “have access” to the start of any arrow in our monoid at the end of any other arrow, which would disallow composition. This means we necessarily only have a single object in our category.</p>
<p>So long as we have a monoid by the classical definition, we have a monoid by the category theoretical definition. The conceptual mapping of formulations (from classical to category theoretical) is:</p>
<ul>
<li><span class="math inline">× → ∘</span></li>
<li><span class="math inline">1 → <em>i</em><em>d</em></span></li>
</ul>
<p>The tricky thing here is that in category-theory-land, the morphisms might not really look like functions, or even arrows, as we might expect. An integer as a category morphism follows the laws if we plug in the right <span class="math inline"><em>i</em><em>d</em></span> and <span class="math inline">∘</span>, and that’s all that matters.</p>
<h2 id="the-connection">The connection</h2>
<p>Let’s formulate the aforementioned <code>Sum</code> as a legitimate haskell <code>Category</code> (<code>C</code> for <code>Category</code>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SumC</span> a b <span class="kw">where</span>
  <span class="dt">SumC</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">SumC</span> a a

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">SumC</span> a b)

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">SumC</span> <span class="kw">where</span>
  id <span class="fu">=</span> <span class="dt">SumC</span> <span class="dv">0</span>
  <span class="dt">SumC</span> x <span class="fu">.</span> <span class="dt">SumC</span> y <span class="fu">=</span> <span class="dt">SumC</span> (x <span class="fu">+</span> y)</code></pre></div>
<p>We can use GADTs to encode the monoid (read: category with a single object) of integers under addition. We are saying two things here:</p>
<ul>
<li>A <code>SumC</code> is constructed by an <code>Integer</code> (effectively, this means that a <code>SumC</code> <em>is</em> an <code>Integer</code>; this is just a wrapper.).</li>
<li>Although we’re providing two type variables to <code>SumC</code>, we can only construct things of type <code>SumC a a</code>.</li>
</ul>
<p>In effect, if we view <code>SumC</code> as <code>cat</code> (the type of morphisms in a category), we can encode the monoid <span class="math inline">{ℤ, +, 0}</span> exactly as a <code>Category</code>. If you look closely, you’ll notice that we only have a single object in our category, and we don’t care what it is. This is exactly <code>a</code>. A <code>SumC</code> can only be constructed in one way, namely, by asserting that its source and target is <code>a</code>. The identity arrow is <code>0</code>, which we’d expect, and composing two arrows is adding their <code>Integer</code> values.</p>
<p>The category laws all hold, which you may check. This instance acts exactly like the builtin <code>Monoid</code> instance for the <code>Sum</code> we saw previously, modulo operator/function names*:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="dt">SumC</span> <span class="dv">8</span> <span class="fu">.</span> id
<span class="dt">SumC</span> <span class="dv">8</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> id <span class="fu">.</span> <span class="dt">SumC</span> <span class="dv">8</span>
<span class="dt">SumC</span> <span class="dv">8</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="dt">SumC</span> <span class="dv">17</span> <span class="fu">.</span> <span class="dt">SumC</span> <span class="dv">90</span>
<span class="dt">SumC</span> <span class="dv">107</span></code></pre></div>
<p><small> * s/id/mempty, s/./+, s/SumC/Sum and you’ve got the original form. </small></p>
<p>Just like with a <code>Category</code>, this isn’t the only <code>Monoid</code> you can encode – you should be able to use this type of construction for any haskell <code>Monoid</code>.</p>
<p>Note that I wouldn’t actually recommend doing this in practice; it’s mainly a mental exercise. That said, I think it’s pretty cool that we can get very close to a category-theoretic formulation of what a monoid is in Haskell!</p>
</div>
</p>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'abstract-nonsense'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

      </section>
      <footer class="footer">
        © 2016 Benjamin Kovach
        <br />
        Site proudly generated by <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
      </footer>
    </div>
    <script src="js/scale.fix.js"></script>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53651640-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
