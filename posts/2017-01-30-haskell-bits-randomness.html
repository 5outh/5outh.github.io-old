<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Benjamin Kovach</title>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="stylesheet" type="text/css" href="../css/site.css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../js/lightbox2/dist/css/lightbox.min.css" />
    <script type="text/javascript" src="../js/lightbox2/dist/js/lightbox-plus-jquery.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  </head>
  <body style="margin-left: auto; margin-right: auto; display: block; max-width:800px">
    <div id="left"></div>
    <div class="wrapper">
      <header>
        <ul id="nav">
    <li><a href="../">Home</a></li>
    <li><a href="http://shop.kovach.me/">Shop</a></li>
    <li><a href="../art.html">Selected Artwork</a></li>
    <li><a href="../contact.html">About</a></li>
    <li><a href="../atom.xml">Atom</a>/<a href="../rss.xml">RSS</a></li>
</ul>


        <h3 id="blog_title">Benjamin Kovach</h3>
      </header>
      <section>
        
          <h4 class="post-title">Haskell Bits #1: Randomness</h4>
        
        <p>
<div class="post_body">
  <p>Haskell Bits is a new series of bite-sized posts that I hope will empower people to “get it done and move on”, providing useful information and links to learn more if desired. I’ll be providing full <code>main</code> files in each example (with imports!) to make porting this stuff into your own project as frictionless as possible. This first “Haskell Bit” will cover randomness.</p>
<p>You need at least two things to produce a random number:</p>
<ul>
<li>An initial “seed” value</li>
<li>A pure function that produces a new number from that seed. (“RNG”)</li>
</ul>
<p>That’s all for a single number.</p>
<p>Most programming languages will hide these details from you unless you need them. Most of the time, you can just call <code>random()</code> and get a random number (typically between 0 and 1), using a seed value generated from some system variable that is always changing (current time in very small units is common).</p>
<p>The simplest way to replicate this behavior in Haskell is by using the <code>System.Random</code> module, part of the <a href="https://hackage.haskell.org/package/random-1.1/docs/System-Random.html"><code>random</code></a> package.</p>
<p>We can use <code>randomIO</code> and <code>randomRIO</code> to pull from a global RNG:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- A random `Double` between 0 and 1</span>
  (<span class="ot">randomIO ::</span> <span class="dt">IO</span> <span class="dt">Double</span>) <span class="fu">&gt;&gt;=</span> print

  <span class="co">-- A random `Int` between 1 and 6 (A die roll)</span>
  randomRIO (<span class="dv">1</span>, <span class="dv">6</span>) <span class="fu">&gt;&gt;=</span> print</code></pre></div>
<p>This is pretty much the interface that most other languages start with. Better would be to separate out IO as much as possible from the inevitable rest of our program. We can do that by confining IO usage to one operation: coming up with an initial RNG.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>

<span class="ot">dieRoll ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Int</span>, g)
dieRoll <span class="fu">=</span> randomR (<span class="dv">1</span>, <span class="dv">6</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- New generator, generated from the system RNG </span>
  gen <span class="ot">&lt;-</span> newStdGen 

  <span class="kw">let</span> (result, newGen) <span class="fu">=</span> dieRoll gen
  print result

  <span class="kw">let</span> (newResult, newNewGen) <span class="fu">=</span> dieRoll newGen
  print newResult </code></pre></div>
<p>We don’t want to duplicate this code every time we want to add a new die roll. The next logical step would be to sprinkle in some <code>State</code> to store the current RNG in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>

<span class="ot">dieRoll ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">State</span> g <span class="dt">Int</span>
dieRoll <span class="fu">=</span> state (randomR (<span class="dv">1</span>, <span class="dv">6</span>))

<span class="ot">twoDice ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">State</span> g <span class="dt">Int</span>
twoDice <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> dieRoll <span class="fu">&lt;*&gt;</span> dieRoll

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  gen <span class="ot">&lt;-</span> newStdGen
  print (evalState twoDice gen)</code></pre></div>
<p>Now we can run more complex programs that employ random numbers. Note that <code>newStdGen</code> can be replaced with <code>mkStdGen :: Int -&gt; StdGen</code> if you want to provide an integral seed instead of using the global <code>StdGen</code>.</p>
<p>You can avoid some of the state boilerplate and get a few more benefits by bringing in the <a href="https://hackage.haskell.org/package/MonadRandom-0.5"><code>MonadRandom</code></a> package. Here’s some code that accomplishes the same goal using <code>MonadRandom</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>
<span class="kw">import </span><span class="dt">Control.Monad.Random</span>

<span class="ot">dieRoll ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g <span class="dt">Int</span>
dieRoll <span class="fu">=</span> getRandomR (<span class="dv">1</span>, <span class="dv">6</span>)

<span class="ot">twoDice ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g <span class="dt">Int</span>
twoDice <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> dieRoll <span class="fu">&lt;*&gt;</span> dieRoll

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  gen <span class="ot">&lt;-</span> newStdGen
  print (evalRand twoDice gen)</code></pre></div>
<p>Apart from providing a nice way to write (slightly) terser randomness code, <code>MonadRandom</code> is more explicit about the domain we’re working in, and ships with a couple of killer utilities; namely, the minimalistic sampling functions <code>uniform</code> and <code>fromList</code> (also <code>weighted</code> from <code>MonadRandom 0.5</code>). This program, for example, generates a list of 20 moves that might come up in a Dance Dance Revolution song:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Random</span>
<span class="kw">import </span><span class="dt">System.Random</span>

<span class="kw">data</span> <span class="dt">Direction</span> <span class="fu">=</span> <span class="dt">U</span> <span class="fu">|</span> <span class="dt">D</span> <span class="fu">|</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="ot">step ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g <span class="dt">Direction</span>
step <span class="fu">=</span> uniform [<span class="dt">U</span>,<span class="dt">D</span>,<span class="dt">L</span>,<span class="dt">R</span>]

<span class="ot">stepWeighted ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g <span class="dt">Direction</span>
stepWeighted <span class="fu">=</span>
    fromList [(<span class="dt">U</span>, <span class="dv">1</span>), (<span class="dt">D</span>, <span class="dv">1</span>), (<span class="dt">L</span>, <span class="dv">50</span>), (<span class="dt">R</span>, <span class="dv">100</span>)]

<span class="ot">danceDanceRevolutionScroll ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g [<span class="dt">Direction</span>]
danceDanceRevolutionScroll <span class="fu">=</span> replicateM <span class="dv">20</span> <span class="fu">$</span> <span class="kw">do</span>
    weightIt <span class="ot">&lt;-</span> uniform [<span class="dt">True</span>, <span class="dt">False</span>]
    <span class="kw">if</span> weightIt <span class="kw">then</span> stepWeighted <span class="kw">else</span> step

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  gen <span class="ot">&lt;-</span> newStdGen
  print (evalRand danceDanceRevolutionScroll gen)</code></pre></div>
<p><code>fromList</code> lets you specify weights for your random elements. <code>L</code> and <code>R</code> will probably show up a lot more than the other two directions when this is run.</p>
<p><code>MonadRandom</code> supplies some other conveniences as well, but it’s not crazy stuffed with functionality. It’s a nice package that contains the minimal amount of code to be useful but not overengineered.</p>
<p>That said, sometimes you need more. First off, what about different distributions? The normal distribution is a pretty common necessity. <a href="https://hackage.haskell.org/package/random-fu"><code>random-fu</code></a> really shines in this domain. You’ll have to pull in the <a href="https://hackage.haskell.org/package/rvar"><code>rvar</code></a> package as well to run this next example, which will print out a random number pulled from a normal distribution with mean <code>100</code> and a standard deviation of <code>5</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.Random</span>
<span class="kw">import </span><span class="dt">Data.Random</span>
<span class="kw">import </span><span class="dt">Data.RVar</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>

<span class="ot">normalNumber ::</span> <span class="dt">State</span> <span class="dt">StdGen</span> <span class="dt">Double</span>
normalNumber <span class="fu">=</span> sampleRVar (normal <span class="dv">100</span> <span class="dv">5</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  gen <span class="ot">&lt;-</span> newStdGen
  print (evalState normalNumber gen)</code></pre></div>
<p>Notice the <code>State</code> pattern from earlier. Also, there a bunch of common distributions that ship with <code>random-fu</code>.</p>
<p>One last thing I should mention is that we’re not tied to <code>StdGen</code>, the RNG that ships with <code>random</code>.</p>
<p>In fact, it does not have strong statistical properties, and should probably be avoided for many “real” applications (See <a href="https://www.reddit.com/r/haskell/comments/3x15sm/why_is_the_first_random_value_produced_from_a/">this reddit post</a>, and thank you to reddit user tom-md for the note!).</p>
<p>There are faster and more stable ones ones, like <code>PureMT</code> from <a href="https://hackage.haskell.org/package/random-source"><code>random-source</code></a> or <code>TFGen</code> from <a href="https://hackage.haskell.org/package/tf-random"><code>tf-random</code></a>. These are both instances of <code>RandomGen</code>, so you can plug either one of those in wherever you saw the generic type signature <code>RandomGen g =&gt; ...</code> in this post. For example, mixing <code>PureMT</code> back into <code>MonadRandom</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Random</span>
<span class="kw">import </span><span class="dt">Data.Random.Source.PureMT</span>

<span class="ot">dieRoll ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Rand</span> g <span class="dt">Int</span>
dieRoll <span class="fu">=</span> getRandomR (<span class="dv">1</span>, <span class="dv">6</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> newPureMT <span class="fu">&gt;&gt;=</span> print <span class="fu">.</span> evalRand dieRoll </code></pre></div>
<p>Is there anything else you’d like to know about randomness in Haskell? Let me know in the comments!</p>
<p>Ben</p>
</div>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'abstract-nonsense'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</p>
      </section>
      <footer class="footer">
        © 2018 Benjamin Kovach
        <br />
        Site proudly generated by <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
      </footer>
    </div>
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-53651640-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script>
      lightbox.option({
        resizeDuration: 200,
      })
    </script>
  </body>
</html>
